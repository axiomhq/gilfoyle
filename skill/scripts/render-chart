#!/usr/bin/env bash
# Render a Chart.js config as a PNG image
#
# Usage: render-chart <output.png> [options] < config.json
#
# Reads Chart.js configuration JSON from stdin, renders to PNG, writes to output path.
# Dark theme by default — suitable for Slack inline previews.
#
# Options:
#   --width <px>    Canvas width (default: 800)
#   --height <px>   Canvas height (default: 400)
#   --light         Use light theme instead of dark
#
# Examples:
#   echo '{"type":"line","data":{"labels":["a","b","c"],"datasets":[{"data":[1,3,2]}]}}' \
#     | render-chart /tmp/chart.png
#
#   render-chart /tmp/wide.png --width 1200 --height 600 < config.json
#
# Requires: chart.js, @napi-rs/canvas (installed in runner/node_modules)

set -euo pipefail

OUTPUT=""
WIDTH=800
HEIGHT=400
THEME="dark"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --width)
      WIDTH="$2"
      shift 2
      ;;
    --height)
      HEIGHT="$2"
      shift 2
      ;;
    --light)
      THEME="light"
      shift
      ;;
    -*)
      echo "Error: Unknown option '$1'" >&2
      echo "Usage: render-chart <output.png> [--width px] [--height px] [--light]" >&2
      exit 1
      ;;
    *)
      if [[ -z "$OUTPUT" ]]; then
        OUTPUT="$1"
      else
        echo "Error: Unexpected argument '$1'" >&2
        exit 1
      fi
      shift
      ;;
  esac
done

if [[ -z "$OUTPUT" ]]; then
  echo "Usage: render-chart <output.png> [--width px] [--height px] [--light]" >&2
  exit 1
fi

if [[ -t 0 ]]; then
  echo "Error: No Chart.js config provided. Pipe JSON to stdin." >&2
  echo "" >&2
  echo "Example:" >&2
  echo '  echo '"'"'{"type":"line","data":{"labels":["a","b"],"datasets":[{"data":[1,2]}]}}'"'"' | render-chart /tmp/chart.png' >&2
  exit 1
fi

CONFIG=$(cat)

# Validate JSON
if ! echo "$CONFIG" | jq empty 2>/dev/null; then
  echo "Error: Invalid JSON on stdin" >&2
  exit 1
fi

# Ensure output directory exists
mkdir -p "$(dirname "$OUTPUT")"

# Render using Node.js with chart.js + @napi-rs/canvas
node - "$OUTPUT" "$WIDTH" "$HEIGHT" "$THEME" "$CONFIG" <<'RENDER_SCRIPT'
const { createCanvas, GlobalFonts } = require('@napi-rs/canvas');
const { Chart, registerables } = require('chart.js');
const fs = require('fs');
const path = require('path');

// Register system fonts if available (Lambda has ttf-dejavu)
const fontDirs = [
  '/usr/share/fonts/ttf-dejavu',
  '/usr/share/fonts/dejavu',
  '/usr/share/fonts',
  '/tmp/fonts',
];
let fontsLoaded = false;
for (const dir of fontDirs) {
  if (fs.existsSync(dir)) {
    const count = GlobalFonts.loadFontsFromDir(dir);
    if (count > 0) { fontsLoaded = true; break; }
  }
}

// Set default font family to one that's available
const families = GlobalFonts.families;
const defaultFamily = families.length > 0 ? families[0].family : 'sans-serif';

Chart.register(...registerables);

const [,, outputPath, widthStr, heightStr, theme, configJson] = process.argv;

const width = parseInt(widthStr, 10);
const height = parseInt(heightStr, 10);
const config = JSON.parse(configJson);

const canvas = createCanvas(width, height);
const ctx = canvas.getContext('2d');

const isDark = theme === 'dark';
const bgColor = isDark ? '#1a1a2e' : '#ffffff';
const textColor = isDark ? '#e0e0e0' : '#333333';
const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)';

// Chart.js plugin to fill background before drawing
const bgPlugin = {
  id: 'customBackground',
  beforeDraw: (chart) => {
    const { ctx: chartCtx, width: w, height: h } = chart;
    chartCtx.save();
    chartCtx.fillStyle = bgColor;
    chartCtx.fillRect(0, 0, w, h);
    chartCtx.restore();
  }
};

// Apply theme defaults
config.options = config.options || {};
config.options.color = config.options.color || textColor;
config.options.font = config.options.font || {};
config.options.font.family = config.options.font.family || defaultFamily;

// Legend
config.options.plugins = config.options.plugins || {};
config.options.plugins.legend = config.options.plugins.legend || {};
config.options.plugins.legend.labels = config.options.plugins.legend.labels || {};
config.options.plugins.legend.labels.color = config.options.plugins.legend.labels.color || textColor;

// Title
config.options.plugins.title = config.options.plugins.title || {};
config.options.plugins.title.color = config.options.plugins.title.color || textColor;

// Scales — only for chart types that use them
const axisTypes = ['line', 'bar', 'scatter', 'bubble'];
if (axisTypes.includes(config.type)) {
  config.options.scales = config.options.scales || {};
  for (const [key, scale] of Object.entries(config.options.scales)) {
    scale.ticks = scale.ticks || {};
    scale.ticks.color = scale.ticks.color || textColor;
    scale.grid = scale.grid || {};
    scale.grid.color = scale.grid.color || gridColor;
    scale.border = scale.border || {};
    scale.border.color = scale.border.color || borderColor;
    scale.title = scale.title || {};
    scale.title.color = scale.title.color || textColor;
  }
  // Ensure x and y exist
  if (!config.options.scales.x) config.options.scales.x = {};
  if (!config.options.scales.y) config.options.scales.y = {};
  for (const axis of ['x', 'y']) {
    const s = config.options.scales[axis];
    s.ticks = s.ticks || {};
    s.ticks.color = s.ticks.color || textColor;
    s.grid = s.grid || {};
    s.grid.color = s.grid.color || gridColor;
    s.border = s.border || {};
    s.border.color = s.border.color || borderColor;
  }
}

// Dataset colors — assign defaults if none provided
if (isDark && config.data && config.data.datasets) {
  const palette = [
    '#00d9ff', '#ff6384', '#36a2eb', '#ffce56', '#4bc0c0',
    '#9966ff', '#ff9f40', '#c9cbcf', '#7cb342', '#e91e63'
  ];
  config.data.datasets.forEach((ds, i) => {
    const color = palette[i % palette.length];
    if (!ds.borderColor) ds.borderColor = color;
    if (!ds.backgroundColor) {
      if (['line', 'scatter', 'radar'].includes(config.type)) {
        ds.backgroundColor = color + '33'; // 20% opacity
      } else {
        ds.backgroundColor = color + 'cc'; // 80% opacity
      }
    }
  });
}

// Disable animation (server-side)
config.options.animation = false;
config.options.responsive = false;

// Register background plugin
config.plugins = config.plugins || [];
config.plugins.push(bgPlugin);

// Create chart
new Chart(ctx, config);

// Write PNG
const buffer = canvas.toBuffer('image/png');
fs.writeFileSync(outputPath, buffer);
RENDER_SCRIPT
